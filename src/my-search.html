<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../bower_components/iron-image/iron-image.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="../bower_components/paper-item/paper-item-body.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="lazy-import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="shared-styles.html">

<dom-module id="my-search">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        padding: 10px;
      }

      #searchResults {
        opacity: 1;
        transition: opacity 0.4s;
        will-change: opacity;
      }

      #searchResults.hidden {
        opacity: 0;
        transition: none;
      }

      paper-icon-item {
        padding: 20px 0;
      }

      iron-image {
        margin-right: 50px;
      }

      paper-icon-button, iron-icon {
        margin-right: 50px;
      }
    </style>

    <iron-ajax
        id="authTokenFunction"
        url="/functions/spotifyauth"
        handle-as="text"
        reject-with-request></iron-ajax>

    <iron-ajax
        id="searchApi"
        url="https://api.spotify.com/v1/search"
        headers$='{"Authorization": "Bearer [[accessToken]]"}'
        params$='{"q":"[[_computeQuery(_searchQuery)]]", "limit":"10", "type":"track", "market":"US"}'
        handle-as="json"
        last-response="{{_response}}"
        reject-with-request
        debounce-duration="300"></iron-ajax>

    <paper-input
        label="Search"
        type="search"
        value="{{_searchQuery}}"
        on-value-changed="_searchChanged"></paper-input>
    
    <div id="searchResults">
      <template is="dom-repeat"
          id="trackRepeat"
          items="[[_response.tracks.items]]"
          as="track"
          on-dom-change="_fadeInOut"
          initial-count="5"
          target-framerate="60">

        <index class="idIndex" track-id$="[[track.id]]"></index>
        <paper-icon-item>
            <!--<iron-image 
              src="[[track.album.images.0.url]]" 
              style="width:100px; height:100px; background-color: lightgray;"
              sizing="cover"
              preload fade></iron-image>-->
          <paper-item-body two-line>
            <div>[[track.name]]</div>
            <div secondary>[[track.artists.0.name]]</div>
          </paper-item-body>
          <paper-icon-button 
              icon="my-icons:add"
              on-tap="_addButtonClicked"
              hidden$="[[_computeTrackAdded(track.id, track.added)]]"></paper-icon-button>
          <iron-icon
              icon="my-icons:check"
              hidden$="[[!_computeTrackAdded(track.id, track.added)]]"></iron-icon>
        </paper-icon-item>
      </template>
    </div>

  </template>

  <script>
    class MySearch extends Polymer.Element {
      static get is() { return 'my-search'; }

      static get properties() {
        return {
          trackMap: Object,
          accessToken: String,
          _searchQuery: String,
        }
      }

      ready() {
        super.ready();
        this.dispatchEvent(new CustomEvent('load-status', { detail: 'load-end', bubbles: true, composed: true }));
      }

      static get observers() {
        return [
          '_trackMapChanged(trackMap.*)'
        ]
      }

      // Listens for added tracks and updates 'added' state in UI model
      _trackMapChanged(trackMapSplices) {
        const trackRepeat = this.$.trackRepeat;
        const track = trackMapSplices.value;
        const trackId = trackMapSplices.path.split('.')[1];
        if (!trackRepeat.items || !trackRepeat.items.length || !trackId) return;
        Polymer.Async.microTask.run(() => {
          try {
            const trackElement = this.shadowRoot.querySelector(`.idIndex[track-id="${trackId}"]`);
            const model = trackRepeat.modelForElement(trackElement);
            model.set('track.added', !!track ? true : false);
          } catch(err) {
            console.log('Error setting track added', err.message);
          }
        });
      }

      _addButtonClicked(event) {
        const track = this.$.trackRepeat.itemForElement(event.target);
        if (!track) return;
        Polymer.Async.timeOut.after(200).run(() => { // Wait for ripple to finish
          SpotifyTogether.addTrack(track.id, track.name, track.artists[0].name, track.album.name);
        });
      }

      _computeTrackAdded(trackId) {
        return !!this.trackMap[trackId];
      }

      _computeQuery(query) {
        // Check if last 2 characters of query are alphanumueric,
        // and if so, add wildcard to query. Wildcard can produce errors
        // without this precaution.
        if (query.length > 1 && /^[a-zA-Z0-9]{2}$/.test(query.slice(-2))) {
          return query += '*';
        }
        return query;
      }

      _searchChanged(_, e) {
        if (!e.value.length)
          return;

        this._debouncer = Polymer.Debouncer.debounce(this._debouncer,
                                                     Polymer.Async.timeOut.after(300),
                                                     this._search.bind(this));
      }

      // Expired token for testing BQCWGr8wlGAX_TDAw3u7UxnUovVdN8-s-o24fi3XABfcxWOxbFugv9ZjfmlJYZ8GPfTShMLJ71uMjpVCERaB_w

      _search() {
        if (this.$.authTokenFunction.loading) {
          return;
        }

        this._launchSearch(this._searchQuery, this.accessToken).catch((err) => {
          if (err.message === 'No token provided' || 
             (err.message === 'The access token expired' && err.status === 401)) {
            return this._getAuthToken().then((response) => {
              this.accessToken = response;
              return this._launchSearch(this._searchQuery, this.accessToken);
            });
          }
        }).catch((err) => {
          console.log('An error occured while searching', err.message);
        });
      }

      // Call cloud function to generate new token
      _getAuthToken() {
        return new Promise((resolve, reject) => {
          this.$.authTokenFunction.generateRequest().completes.then((req) => {
            resolve(req.response);
          }).catch((err) => {
            reject(err);
          });
        });
      }

      _launchSearch(query, token) {
        return new Promise((resolve, reject) => {
          if (!query || !query.length) {
            return reject(new TypeError('No query provided'))
          }
          if (!token || !token.length) {
            return reject(new TypeError('No token provided'));
          }
          this.$.searchApi.generateRequest().completes.then((req) => {
            resolve(req.response);
          }).catch((err) => {
            const networkError = {message: 'Network Error', status: 0};
            const error = !!err.request.response ? err.request.response.error : networkError;
            reject(error);
          });
        });
      }

      _fadeInOut() {
        this.$.searchResults.classList.add('hidden');
        Polymer.Async.timeOut.after(1).run(() => {
          this.$.searchResults.classList.remove('hidden');
        });
      }
    }

    window.customElements.define(MySearch.is, MySearch);
  </script>
</dom-module>
