
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/app-layout/app-header/app-header.html">
<link rel="import" href="../bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
<link rel="import" href="../bower_components/app-layout/app-toolbar/app-toolbar.html">
<link rel="import" href="../bower_components/app-route/app-location.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="../bower_components/iron-meta/iron-meta.html">
<link rel="import" href="../bower_components/iron-pages/iron-pages.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-media-query/iron-media-query.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="lazy-import" href="../bower_components/paper-input/paper-input.html">
<link rel="lazy-import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="lazy-import" href="../bower_components/paper-button/paper-button.html">

<link rel="import" href="firebase-scripts.html">
<link rel="import" href="spotify-together-script.html">
<link rel="import" href="tracks-data.html">
<link rel="import" href="spotify-token-data.html">
<link rel="import" href="my-join.html">
<link rel="lazy-import" href="my-queue.html">
<link rel="lazy-import" href="my-party.html">
<link rel="lazy-import" href="my-search.html">
<link rel="lazy-import" href="my-404.html">
<link rel="lazy-import" href="app-bottom-tabs.html">
<link rel="lazy-import" href="app-bottom-tab.html">
<link rel="lazy-import" href="my-icons.html">

<dom-module id="my-app">
  <template>
    <style>
      [hidden] {
        display: none !important;
      }

      :host {
        display: block;
        position: relative;
        height: 100%;

        --primary-color: #1DB954; /* Spotify green */
        --accent-color: #1DB954; /* Spotify green */
        --app-bar-color: #212121;
        --card-color: #424242;
        --divider-color: rgba(255, 255, 255, 0.12);
        --primary-text-color: #FFFFFF;
        --secondary-text-color: rgba(255, 255, 255, 0.7);
        --icon-color: #FFFFFF;
        --secondary-color: #9E9E9E;
        --primary-background-color: #303030;
        --disabled-color: rgba(255, 255, 255, 0.5);
        --error-color: #DD2C00;

        --paper-spinner-color: var(--primary-color);
        --app-bar-height: 48px;
        --app-bottom-tabs-height: 48px;
        --app-bottom-tab-width: 60px;
        color: var(--primary-text-color);
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);

        --no-select: {
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          -khtml-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
        };
      }

      #loadingOverlay {
        @apply --layout;
        @apply --layout-center-center;

        position: absolute;
        top: 0;
        height: 100vh;
        width: 100%;
        z-index: 1;
        visibility: visible;
        opacity: 1;
        transition: visibility 0.2s, opacity 0.2s;
        background: var(--primary-background-color);
      }

      #loadingOverlay.hidden {
        visibility: hidden;
        opacity: 0;
      }

      #loadingSpinner {
        position: relative;
        bottom: 40px;
      }

      #header {
        @apply --layout-fixed-top;

        z-index: 2;
        background-color: var(--app-bar-color);

        --app-header-shadow: {
          box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.2);
          height: 10px;
          bottom: -10px;
        };
      }

      #toolbar {
        position: relative;
        height: 48px;
      }

      paper-button {
        height: 30px;
      }
    
      #appPages {
        max-width: 1440px;
        margin: 0 auto;
        padding-top: var(--app-bar-height);
      }

      .app-page {
        opacity: 0;
        transition: opacity 1s;
      }

      .app-page.iron-selected {
        opacity: 1;
        transition: opacity 1s;
      }
  
      #appTabs {
        @apply --layout-fixed-bottom;

        z-index: 2;
        background-color: var(--app-bar-color);
      }

      #appTabs[selected="join"] {
        display: none;
      }

      .app-tab[unresolved] {
        display: none;
      }

      /* Only needed for Safari */
      .app-tab.iron-selected > a {
        color: var(--primary-text-color);
      }
      .app-tab.touch-active > a {
        color: rgba(255, 255, 255, 0.1);
      }

      .tab-icon {
        width: 24px;
        height: 24px;
      }

      /* Reasonable guess for height when onscreen
         keyboards are visible */
      @media (max-height: 500px) {
        #appTabs {
          display: none;
        }

        #loadingOverlay {
          visibility: hidden;
        }
      }
    </style>

    <app-location route="{{route}}"></app-location>

    <app-route
        route="{{route}}"
        pattern="/:page"
        data="{{routeData}}"
        tail="{{subRoute}}"></app-route>

    <iron-meta key="phoneMaxWidth" value="[[phoneMaxWidth]]"></iron-meta>

    <iron-media-query query="[[phoneMaxWidth]]" query-matches="{{smallScreen}}"></iron-media-query>

    <!-- Loading spinner overlay -->
    <div id="loadingOverlay" class$="[[_computeOverlayClass(loading)]]">
      <paper-spinner-lite id="loadingSpinner" active="[[loading]]"></paper-spinner-lite>
    </div>

    <app-header id="header" role="navigation" condenses reveals effects="waterfall">
      <app-toolbar id="toolbar">
        <div main-title>Spotify Together</div>
        <paper-button raised hidden$="[[signedIn]]" on-tap="_login">SIGN-IN</paper-button>
        <paper-button raised hidden$="[[!signedIn]]" on-tap="_logout">LOGOUT</paper-button>
      </app-toolbar>
    </app-header>

    <tracks-data queue="{{tracks}}" track-id-map="{{trackMap}}"></tracks-data>
    <spotify-token-data access-token="{{token}}"></spotify-token-data>
    <iron-pages id="appPages" selected="[[page]]" attr-for-selected="name" fallback-selection="404" role="main">
      <my-join class="app-page" name="join"></my-join>
      <my-party class="app-page" name="party"></my-party>
      <my-queue class="app-page" name="queue" tracks="[[tracks]]"></my-queue>
      <my-search class="app-page" name="search" track-map="[[trackMap]]" access-token="[[token]]"></my-search>
      <my-404 class="app-page" name="404"></my-404>
    </iron-pages>
    
    <app-bottom-tabs unresolved class="unresolved" id="appTabs" selected="[[page]]" attr-for-selected="name">
      <app-bottom-tab unresolved class="app-tab" name="party">
        <a href="party">
          <iron-icon class="tab-icon" icon="my-icons:cake"></iron-icon>
          Party
        </a>
      </app-bottom-tab>
      <app-bottom-tab unresolved class="app-tab" name="queue">
        <a href="queue">          
          <iron-icon class="tab-icon" icon="my-icons:queue-music"></iron-icon>
          Queue
        </a>
      </app-bottom-tab>
      <app-bottom-tab unresolved class="app-tab" name="search">
        <a href="search">
          <iron-icon class="tab-icon" icon="my-icons:search"></iron-icon>
          Search
        </a>
      </app-bottom-tab>
    </app-bottom-tabs>

  </template>

  <script>

    window.performance && performance.mark && performance.mark('app - before register');

    class MyApp extends Polymer.Element {

      static get is() { return 'my-app'; }

      static get properties() {
        return {
          page: {
            type: String,
            reflectToAttribute: true,
            observer: '_pageChanged',
          },

          loading: {
            type: Boolean,
            value: true
          },

          _loadStatus: {
            type: Number,
            value: 1
          },

          partyId: String,

          signedIn: {
            type: Boolean,
            value: false
          },

          _authStatusKnown: Boolean,

          subRoute: String,

          routeData: Object,

          // meta
          pages: {
            type: Array,
            value: ['join', 'party', 'queue', 'search']
          },

          phoneMaxWidth: {
            type: String,
            value: 'max-width: 640px',
          },

        };
      }

      static get observers() {
        return [
          '_lockScroll(loadComplete)',
          '_routePageChanged(routeData.page)'
        ];
      }

      constructor() {
        super();

        window.performance && performance.mark && performance.mark('app.created');

        // This listener needs to be added early to capture load events from page children
        this.addEventListener('load-status', (e) => this._onLoadStatus(e));
        this.loadedPages = {};

        var config = {
          apiKey: "AIzaSyBJxf-hJa7RQVBPYkdjt27yBcDj0b1tG8o",
          authDomain: "spotify-party-da303.firebaseapp.com",
          databaseURL: "https://spotify-party-da303.firebaseio.com/"
        };
        firebase.initializeApp(config);
        SpotifyTogether = new SpotifyTogether(firebase.database().ref());
        this._handleRedirect().then(() => {
          // Bind auth listener
          firebase.auth().onAuthStateChanged(this.__onAuthStateChanged.bind(this));
        });
      }

      connectedCallback() {
        super.connectedCallback();
      }

      ready() {
        super.ready();
        // Custom elements polyfill safe way to indicate an element has been upgraded.
        this.removeAttribute('unresolved');
        // listen for custom events
        this.addEventListener('announce', (e) => this._onAnnounce(e));
        this.addEventListener('dom-change', (e) => this._domChange(e));
        this.addEventListener('show-invalid-url-warning', (e) => this._onFallbackSelectionTriggered(e));

        SpotifyTogether.on('user-update', this.__onUserUpdate.bind(this));
        SpotifyTogether.on('party-enter', this.__onEnterParty.bind(this));
        SpotifyTogether.on('party-leave', this.__onLeaveParty.bind(this));

        Polymer.RenderStatus.afterNextRender(this, () => {
          window.addEventListener('online', (e) => this._notifyNetworkStatus(e));
          window.addEventListener('offline', (e) => this._notifyNetworkStatus(e));
        });
      }

      __onAuthStateChanged(user) {
        if (!!user) {
          SpotifyTogether.setUser(user.uid, user.displayName, user.isAnonymous).then((user) => {
            return SpotifyTogether.getUserParty();
          }).then((partyId) => {
            if (!!partyId) {
              return SpotifyTogether.enterParty(partyId);
            } else {
              this._partyStatusRedirect(null, this.page);
            }
          });
        } else {
          this._partyStatusRedirect(null, this.page);
        }
        this.dispatchEvent(new CustomEvent('load-status', { detail: 'load-end' }));
      }

      _routePageChanged(page) {
        if (page === 'index.html') {
          this.set('route.path', '/');
          return;
        }
        this.page = page || 'join';
      }

      _pageChanged(page, oldPage) {
        if (page != null) {
          // home route is eagerly loaded
          if (page == 'join') {
            this._pageLoaded(Boolean(oldPage));
          // other routes are lazy loaded
          } else {
            if (!this.loadedPages[page]) {
              this.dispatchEvent(new CustomEvent('load-status', { detail: 'load-start' }));
            }
            // When a load failed, it triggered a 404 which means we need to
            // eagerly load the 404 page definition
            let cb = this._pageLoaded.bind(this, page, Boolean(oldPage));
            Polymer.importHref(
                this.resolveUrl(`my-${page}.html`),
                cb, cb, true);
          }
        }
      }

      _pageLoaded(page, shouldResetLayout) {
        this.loadedPages[page] = true;
        this._ensureLazyLoaded();
        if (shouldResetLayout) {
          Polymer.Async.timeOut.run(() => {
            this.$.header.resetLayout();
          }, 1);
        }
      }
      
      _ensureLazyLoaded() {
        // load lazy resources after render and set `loadComplete` when done.
        if (!this.loadComplete) {
          Polymer.RenderStatus.afterNextRender(this, () => {
            Polymer.importHref(this.resolveUrl('lazy-resources.html'), () => {
              // Register service worker if supported.
              if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('service-worker.js', {scope: '/'});
              }
              this._notifyNetworkStatus();
              this.loadComplete = true;
            }, null, true);
          });
        }
      }

      _partyStatusRedirect(partyId, page) {
        if (partyId === undefined) return true;
        if (!!partyId) {
          if (page === 'join') {
            this.set('route.path', 'queue');
            return true;
          }
        } else if (this.pages.includes(page) && page !== 'join') {
          this.set('route.path', 'join');
          return true;
        }
        return false;
      }

      _notifyNetworkStatus() {
        let oldOffline = this.offline;
        this.offline = !navigator.onLine;
        // Show the snackbar if the user is offline when starting a new session
        // or if the network status changed.
        /*if (this.offline || (!this.offline && oldOffline === true)) {
          if (!this._networkSnackbar) {
            this._networkSnackbar = document.createElement('shop-snackbar');
            this.root.appendChild(this._networkSnackbar);
          }
          this._networkSnackbar.innerHTML = this.offline ?
              'You are offline' : 'You are online';
          this._networkSnackbar.open();
        }*/
      }

      _login() {
        const provider = new firebase.auth.GoogleAuthProvider();
        if (this.user && this.user.isAnonymous) {
          firebase.auth().currentUser.linkWithRedirect(provider);
        } else {
          firebase.auth().signInWithRedirect(provider);
        }
      }

      _logout() {
        // should use button's on transition end
        firebase.auth().signOut().then(() => {
          location.reload();
        });
      }

      _handleRedirect() {
        return firebase.auth().getRedirectResult().then((result) => {
          if (!!result.credential) {
            console.log('Successful link');
          } else {
            console.log('This is not a redirect');
          }
        }).catch((err) => {
          console.log(err.message);

          const prevUser = firebase.auth().currentUser;
          if (!prevUser) {
            console.log('No anon user. This should not happen');
            return;
          }

          const credential = err.credential;
          let prevParty = null;

          return firebase.database().ref('users').child(prevUser.uid).child('party').once('value').then((snapshot) => {
            prevParty = snapshot.val();
            const updates = {};
            if (!!prevParty) {
              updates[`party-members/${prevParty}/${prevUser.uid}`] = null;
            }
            updates[`users/${prevUser.uid}`] = null;
            firebase.database().ref().update(updates);
            prevUser.delete().catch((err) => {
              console.log('Error deleting user', err.message);
            });
            return firebase.auth().signInWithCredential(credential);
          }).then((user) => {
            return firebase.database().ref('users').child(user.uid).child('party').once('value').then((snapshot) => {
              const currParty = snapshot.val();
              if (prevParty && prevParty !== currParty) {
                const updates = {};
                updates[`users/${user.uid}/party`] = prevParty;
                updates[`party-members/${prevParty}/${user.uid}`] = true;
                if (!currParty) {
                  updates[`party-members/${currParty}/${user.uid}`] = null;
                }
                return firebase.database().ref().update(updates);
              }
            });
          }).catch((err) => {
            console.log('Error switching parties', err.message);
          });
        });
      }

      _domChange(e) {
        if (window.performance && performance.mark && !this.__loggedDomChange) {
          let target = e.composedPath()[0];
          let host = target.getRootNode().host;
          if (host && host.localName.match(this.page)) {
            this.__loggedDomChange = true;
            performance.mark(host.localName + '.domChange');
          }
        }
      }

      _onFallbackSelectionTriggered() {
        this.page = '404';
      }

      __onUserUpdate(user) {
        this.user = user;
        this.signedIn = (!!user && !user.isAnonymous);
      }

      __onEnterParty(partyId) {
        this._partyStatusRedirect(partyId, this.page);
        this.partyId = partyId;
      }

      __onLeaveParty(partyId) {
        this._partyStatusRedirect(null, this.page);
        this.partyId = null;
      }

      _onLoadStatus(event) {
        event.detail === 'load-start' ? this._loadStatus++ : this._loadStatus--;
        this._loadStatus = this._loadStatus < 0 ? 0 : this._loadStatus;
        this.loading = (this._loadStatus > 0);
      }

      _lockScroll(loadComplete) {
        //document.body.style.overflow = loadComplete ? 'visible' : 'hidden';
        //document.body.style.overflow = 'hidden';
      }

      _computeOverlayClass(loading) {
        return loading ? '' : 'hidden';
      }

    }

    window.customElements.define(MyApp.is, MyApp);
  </script>
</dom-module>
