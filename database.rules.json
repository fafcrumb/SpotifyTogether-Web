{
  // Spotify Together security rules
  "rules": {
    // By default, make all data private unless specified otherwise.
    ".read": false,
    ".write": false,
    "party-metadata": {
      ".read": true,
      "$partyId": {
        // Append-only by anyone, but the host can edit their own party
        ".write": "(auth != null) && (!data.exists() || data.child('host').val() === auth.uid)",
        ".validate": "newData.hasChildren(['type','host','code'])",
        "id": {
          ".validate": "(newData.val() === $partyId)"
        },
        "host": {
          ".validate": "(auth.uid === newData.val())"
        },
        /*"numUsers": {
          ".validate": "(newData.isNumber())"
        },*/
        "type": {
          ".validate": "('anonymous-friendly' === newData.val() || 'sign-in-only' === newData.val())"
        },
        "code": {
          ".validate": "(newData.val().matches(/^[A-Z]{4}$/))"
        }
        /* "$other": {
          ".validate": false
        }*/
      }
    },
    "party-tracks": {
      "$partyId": {
        // Lists of tracks by party, viewable by anyone in the party.
        ".read": "(root.child('party-members').child($partyId).hasChild(auth.uid))",
        "$trackId": {
          // Allow anyone in the party to append non-duplicates to this list.
          ".write": "(auth != null) && (auth.provider != 'anonymous') && (!data.exists()) && (newData.exists()) && (root.child('party-members').child($partyId).hasChild(auth.uid))",
          ".validate": "(newData.hasChildren(['userId','spotifyTrackId','timestamp']))",
          ".indexOn": "timestamp",
          "userId": {
            ".validate": "(newData.val() === auth.uid)"
          },
          // Can't add a track if the time this user last added a track was less than 10 seconds ago
          "timestamp": {
            ".validate": "(newData.val() === now) && (!root.child('users').child(auth.uid).child('last-submitted-times').hasChild($partyId) || newData.val() - root.child('users').child(auth.uid).child('last-submitted-times').child($partyId).child('time').val() > 10000)"
          },
          "spotifyTrackId": {
            ".validate": "(newData.val() === $trackId)"
          },
          "votes": {
            // A list of votes on this track, which any non-anonymous member of the party can add or remove themselves to/from, except the user who added this track.
            ".validate": "(data.parent().child('userId').val() !== auth.uid)",
            "$userId": {
              ".write": "(auth != null) && ($userId === auth.uid) && (auth.provider != 'anonymous')",
              ".validate": "(newData.val() === true)"
            }
          }
          /* "$other": {
            ".validate": false
          }*/
        }
      }
    },
    "party-members": {
      "$partyId": {
        // Anyone in the party can read the list of members
        ".read": "(root.child('party-members').child($partyId).hasChild(auth.uid))",
        "$userId": {
          // A list of users by party, which any user can add or remove themselves to/from. Hosts can add or remove anyone in their party.
          ".write": "(auth != null) && ($userId === auth.uid || root.child('party-metadata').child($partyId).child('host').val() === auth.uid) && (newData.exists() || newData.parent().parent().parent().child('users').child($userId).child('party').val() !== $partyId)",
          ".validate": "(newData.parent().parent().parent().child('users').child($userId).child('party').val() === $partyId)"
          /*"$sessionId": {
            ".validate": "(!newData.exists() || newData.hasChildren(['id','name']))"
          }*/
        }
      }
    },
    "party-codes": {
      ".read": true,
      "$code": {
        // One to one mapping of 4 letter codes to party id's, only hosts can add or remove their own parties from this mapping.
        ".write": "(auth != null) && (root.child('party-metadata').child(newData.val()).child('host').val() === auth.uid)",
        ".validate": "($code === root.child('party-metadata').child(newData.val()).child('code').val())"
      }
    },
    "users": {
      // A list of users and their associated metadata, which can be updated by the single user.
      "$userId": {
        // Keep in mind this is overwritting lower level write rules.
        ".write": "(auth != null) && (auth.uid === $userId) && (!newData.exists())",
        ".read": "(auth != null) && (auth.uid === $userId)",
        // The party this user is in, which must be added/deleted both here and in party-members at the same time.
        "party": {
          ".write": "(newData.exists() || !newData.parent().parent().parent().child('party-members').child(data.val()).hasChild($userId))",
          ".validate": "(newData.parent().parent().parent().child('party-members').child(newData.val()).hasChild($userId))"
        },
        "last-submitted-times": {
          "$partyId": {
            ".write": "(newData.exists())",
            // When a user submits a new track, they must also write it's timestamp and id here.
            //".validate": "(newData.child('timestamp').val() === newData.parent().parent().parent().child('party-tracks').child($partyId).child(newData.child('trackId').val()).child('timestamp').val())",
            "time": {
              ".validate": "newData.val() === now"
            }
          }
        },
        "meta-data": {
          ".write": "(auth != null) && (auth.uid === $userId) && (newData.hasChildren(['id', 'name', 'isAnonymous']))",
          "id": {
            ".validate": "(newData.val() === $userId)"
          },
          "name": {
            ".validate": "(newData.isString()) && (newData.val() === (auth.provider == 'anonymous' ? 'Anon' : auth.token.name))"
          },
          "isAnonymous": {
            ".validate": "(newData.isBoolean()) && (newData.val() === (auth.provider == 'anonymous'))"
          }
        }
        /*"isAnonymous": {
          ".validate": "newData.val() === auth.isAnonymous"
        }*/
        /*"invites": {
          // A list of chat invitations from other users, append-only by anyone.
          "$inviteId": {
            // Allow the user who created the invitation to read the status of the invitation.
            ".read": "(auth != null) && (auth.uid === data.child('fromUserId').val())",
            ".write": "(auth != null) && (!data.exists() || $userId === auth.uid || data.child('fromUserId').val() === auth.uid)",
            ".validate": "newData.hasChildren(['fromUserId','fromUserName','roomId']) && (newData.child('id').val() === $inviteId)"
          }
        },*/
        /*"notifications": {
          // A list of notifications, which can only be appended to by moderators.
          "$notificationId": {
            ".write": "(auth != null) && (data.val() === null) && (root.child('moderators').hasChild(auth.uid))",
            ".validate": "newData.hasChildren(['fromUserId','timestamp','notificationType'])",
            "fromUserId": {
              ".validate": "newData.val() === auth.uid"
            }
          }
        }*/
      }
    },
    "spotify-api-metadata": {
      ".read": true,
      ".write": false
    }
  }
}
